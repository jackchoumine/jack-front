## 遇到的问题

1.  异步导入组件报错

> Uncaught (in promise) TypeError: Cannot read properties of undefined (reading '\_\_asyncLoader')

```js
const tab = [
  {
    key: () => import('component/path'),
  },
]
```

类似问题：[vue3 项目\_\_asyncLoader 报 undefined 的问题处理](https://segmentfault.com/a/1190000040748957)

[Throw an error on createVNode with using innerHTML and children at the same time](https://github.com/vuejs/core/issues/5081)

2. JSX debugger 无法执行到

```jsx
const Button = defineComponent({
  setup(props, { slots }) {
    console.log('*****slots')
    console.log(slots)
    const { default: _default, left, right } = slots
    //NOTE  CAN NOT REACH HERE
    debugger
    return () => (
      <button style={style}>
        {left ? left() : null}
        {_default ? _default() : 'BUTTON'}
        {right ? right() : null}
      </button>
    )
  },
})
```

[vite issue](https://github.com/vitejs/vite/issues/5916)

```ts
type Keys = 'id' | 'name'
type Limit = Record<string, string> & { [key in Keys]?: never } // 不含有某些key
const b: Limit = { age: '' }
const c: Limit = { c: '', ...b }

const aaa = (data: Limit) => {}
aaa({ id: '' })
const bbb = (data: Limit) => {
  const b = { ccc: '12', ...data }
  aaa(b)
}
```

```ts
type A = () => false
const b = (): boolean => false
const b1: () => boolean = () => false
// b b1 的类型一样，值一样
const a = (): boolean | { delay?: number } => false
const d: () => boolean | { delay?: number } = () => false
a()
console.log(b())
d()
```

> 三元运算符 booleanValue ? value1 : value2 对象属性 {key: value} 的 : 右边是值，其他都是类型

> 箭头右边，可以是值，可以是类型 type Fn = () => boolean

> ts 定义组件 props 不支持复杂操作

```bash
类型字面量 # type PropsDefine = Partial<Props> 这种不支持
在同一文档中的接口或类型字面量的引用 # 从外部导出类型，不支持
```

> TypeError: dataOptions.call is not a function

原因：ref 绑定的变量和组件名字相同，会报错。

```html
<script>
  const elForm = ref(null)
</script>
<template>
  <div class="time-form my-2.5">
    <el-form
      label-position="right"
      label-width="100px"
      :model="formValue"
      :rules="rules"
      ref="elForm">
    </el-form>
  </div>
</template>
```

解决：修改 ref 绑定的变量名字。

## HMR 无效

[控制台输出 hmr update ，但是浏览器没更新](https://github.com/vitejs/vite/issues/7839)

尝试了 [Fixing Hot Module Reload of Vite App in WSL](https://www.youtube.com/watch?v=BUClW9wTqGQ)

```js
{
  "server": {
    "hmr": true,
    "watch": {
      "usePolling": true
    }
  }
}
```

还没找到解决办法。

```js
// 下载文件
export const download = function (v, filename) {
  let { headers, data } = v
  let fname
  if (headers) {
    fname = headers.filename
  } else {
    fname = filename
  }
  let name = decodeURI(fname)
  let blob = new Blob([data], {
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  })
  const a = document.createElement('a')
  a.setAttribute('download', name)
  a.href = window.URL.createObjectURL(blob)
  a.click()
  a.remove()
}
```

## 不要让接口进行再次映射

原因：

1. 不同的人，编写的映射会不同，同一个接口，极可能存在多个映射。比如`station-service/monitorObject/findObjectBySttype`，给维护代码麻烦

2. 不方便从浏览器复制接口 url，在代码里查找接口

改善建议：取消接口映射，直接在接口请求函数里编写 url，当接口路径有变化时，直接全局搜索，再替换。

## import 语句合并

![](./import%E9%9C%80%E8%A6%81%E5%90%88%E5%B9%B6.png)

## new 需要大写

![](./new-%E9%9C%80%E8%A6%81%E5%A4%A7%E5%B0%8F0.png)

## 函数太大、if 嵌套太深

```js
  const getOnLoadTable=(adcd)=>{
    sources.value=[];
    loading.value=true;
    let param={pageNum:pagination.value.page, pageSize:pagination.value.size,keyword:searchKey.value,adcd:adcd||store.user.adcd,org:radioRow.value==='-1'?null:radioRow.value}
    store.api.from("system.query.risk.region.act", param).then((data: any) => {
      if(data){
        loading.value=false;
        pagination.value=data.pagination;
        pagination.value.total=parseInt(data.pagination.total);
        if(data.source&&data.source.length>0){
          let obj = {},threeObj={},tetList=[];
          data.source.forEach(e=>{
            if(e.metrics||e.inCharges||e.rainMetrics||e.stations){
              let lenArray=[];
              if(e.rainMetrics&&Object.keys(e.rainMetrics).length){
                if(e.rainMetrics){
                  lenArray.push(Object.keys(e.rainMetrics).length)
                }
              }
              if(e.metrics&&e.metrics.length){
                if(e.metrics){
                  lenArray.push(e.metrics.length)
                }
              }
              if(e.inCharges&&e.inCharges.length){
                if(e.inCharges){
                  lenArray.push(e.inCharges.length)
                }
              }
              if(e.stations&&e.stations.length){
                if(e.stations){
                  lenArray.push(e.stations.length)
                }
              }
              if(e.refugeList&&e.refugeList.length){
                if(e.refugeList){
                  lenArray.push(e.refugeList.length)
                }
              }
              let len=getArrayMax(lenArray);

              obj = Object.assign(e);
              if(e.rainMetrics&&JSON.stringify(e.rainMetrics) !== "{}"){
                let arr = Object.getOwnPropertyNames(e.rainMetrics);
                if(arr.length!==0){
                  if(e.rainPeriod&&e.rainPeriod.length>0){
                    e.rainPeriod.map(field=>{
                          if(e.rainMetrics[field].length>0){
                            let oneObj,twoObj;
                            e.rainMetrics[field].forEach(b=>{
                              if(b.warnName==="准备转移"){
                                twoObj=assign({},oneObj,{
                                  intv: field,
                                  warnName: b.warnName,
                                  warnGradeId: b.warnGradeId,
                                  period: b.period,
                                  crp: b.crp,
                                });
                                tetList.push(twoObj);
                              }
                              if(b.warnName==="立即转移"){
                                oneObj=assign({},b,{
                                  intv: field,
                                  warnName: b.warnName,
                                  warnGradeId: b.warnGradeId,
                                  period: b.period,
                                  crp: b.crp,
                                });
                                tetList.push(oneObj);
                              }
                            });
                          }
                        }
                    )
                  }

                  tetList.forEach(v=>{
                    if(v.warnName==="准备转移"){
                      threeObj["prepareTime"+v.period]=v.crp
                    }
                    if(v.warnName==="立即转移"){
                      threeObj["immediatelyTime"+v.period]=v.crp
                    }
                  });
                }
              }
              if(len>0){
                let rainMetricsObjOne,rainMetricsObjTwo,fourArr=[];
                if(e.rainPeriod&&e.rainPeriod.length>0){
                  e.rainPeriod.map(field=>{
                    if(e.rainMetrics[field].length>0){
                      e.rainMetrics[field].forEach(b=>{
                        if(b.warnName==="准备转移"){
                          rainMetricsObjTwo=assign({},rainMetricsObjOne,{
                            periodName:b.crp
                          });
                        }
                        if(b.warnName==="立即转移"){
                          rainMetricsObjOne=assign({},b,{
                            intv: field,
                            periodTwoName:b.crp
                          });
                        }
                      });
                      fourArr.push(assign({},obj,rainMetricsObjTwo));
                    }
                  })
                }
                for(let i=0;i<len;i++){
                  let oneObj,twoObj,threeObj,fourObj;
                  if(e.metrics&&e.metrics.length>0){
                    let metricsObjOne={},metricsObjTwo={};
                    e.metrics.forEach(n=>{
                      if(n.warnGradeId===1){
                        metricsObjOne =assign({},n,{
                          checkWater:n.stageThreshold
                        });
                      }
                      if(n.warnGradeId===2){
                        metricsObjTwo =assign({},e.metrics[i],{
                          designWater:n.stageThreshold
                        });
                      }
                    });
                    oneObj=assign({},obj,assign({},metricsObjOne,metricsObjTwo));
                  }else{
                    oneObj=assign({},obj);
                  }
                  if(e.inCharges&&e.inCharges[i]){
                    twoObj=assign({},oneObj,{zrrname:e.inCharges[i].name,zrrremark:e.inCharges[i].remark,phone:e.inCharges[i].phone,title:e.inCharges[i].title,type:e.inCharges[i].type,typeStr:e.inCharges[i].typeStr,});
                  }
                  if(e.stations&&e.stations[i]){
                    threeObj=assign({},oneObj,{stationsName:e.stations[i].stnm,stationsId:e.stations[i].stcd,stationsType:e.stations[i].typeStr,});
                  }
                  if(e.refugeList&&e.refugeList[i]){
                    fourObj=assign({},oneObj,{capacity:e.refugeList[i].capacity,refuge:e.refugeList[i].refuge,placelgtd:e.refugeList[i].lgtd,placelttd:e.refugeList[i].lttd,});
                  }
                  sources.value.push(assign({},assign({},assign({},threeObj,assign({},assign({},oneObj,fourObj),twoObj)),assign({},threeObj)),fourArr[i]));
                }
                spanRainArr.value = [];
                getSpanRainArr(sources.value);
              }else{
                sources.value.push(assign({},obj));
                spanRainArr.value = [];
                getSpanRainArr(sources.value);
              }
            }
          });
        }
      }else {
        loading.value=false;
      }
    }).catch((error: any) => {
      loading.value=false;
      Lookup.store.notify({message: error});
    }).finally(()=>{
      tableAreaStationRelation.value.doLayout()
    });
  };
```
以上代码存在四个突出问题：

1. 没有任何良好的排版，比如行宽`175`个字符，阅读体验不好

2. 函数行数过多，`158`行

3. if 嵌套太多，圈复杂度为`5`，5层嵌套

4. 语法套娃

`assign({},assign({},assign({},threeObj,assign({},assign({},oneObj,fourObj),twoObj)`

它的意图是合并多个对对象，套娃过深，也造成圈复杂度。

改善：使用 `...` 开展操作符。

`const mergeObj= {...threeObj, ...oneObj,...fourObj,...twoObj}` 

> 顺序重要

这些代码难以阅读，难以维护。

### 不要解构 props

```ts
const { target } = defineProps(['target'])
```

### 使用了老版本的lodash


### vue 语法错误


```html
<el-descriptions v-if="tableData.dangerArea.CommunicationInfoVO && tableData.dangerArea.CommunicationInfoVO[0]"
  :column="2" border>
    <template v-for="item of tableData.dangerArea.CommunicationInfoVO">
      <el-descriptions-item label="责任人">{{ item.name }} 
    </template>
 </el-descriptions>
```

```html
<el-descriptions v-if=" tableData.dangerArea.CommunicationInfoVO?.length">
  <template v-for="item of tableData.dangerArea.CommunicationInfoVO">
    <el-descriptions-item label="责任人">{{ item.name }} 
  </template>
 </el-descriptions>
```